<html>
<head>
  <title>Kachnicka</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.4.0/Chart.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cosmo/bootstrap.min.css" integrity="sha384-h21C2fcDk/eFsW9sC9h0dhokq5pDinLNklTKoxIZRUn3+hvmgQSffLLQ4G4l2eEr" crossorigin="anonymous"><style>
  <style>
    canvas {
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }
    #chart-container {
      box-sizing: border-box;
      padding: 10px;
      height: 70%;
      min-height: 250px;
      max-height: 400px;
      width: 100%
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <h1>Graph</h1>
    <div id="chart-container" />
  </div>

  <script>
    // Compile-time constants

    Chart.defaults.global.animation.duration = 0
    const displayLimit = 50

    // Run-time constants

    var lastUpdate = undefined

    const graph = (() => {
      let canvas = document.createElement("canvas")
      document.getElementById("chart-container").appendChild(canvas)

      let ctx = canvas.getContext('2d')
      let chartOptions = {
        type: 'line',
        data: {
          labels: [],
          datasets: []
        },
        options: {
          responsive: true,
          tooltips: {
            mode: 'index',
            intersect: false,
          },
          maintainAspectRatio: false,
          spanGaps: false,
          elements: {
            line: {
              tension: 0.000001
            }
          },
          plugins: {
            filler: {
              propagate: false
            }
          },
          scales: {
            xAxes: [{
              display: true,
              ticks: {
                minRotation: 45,
                autoSkip: false,
                fontSize: 11,
              }
            }],
            yAxes: [{
              display: true,
              beginAtZero: true,
              ticks: {
                fontSize: 10,
              }
            }]
          }
        }
      }
      return new Chart(ctx, chartOptions)
    })()

    // Workflow functions

    const refreshData = (chart, times, d_sizes, ds_sizes) => {
      chart.data.labels = times
      chart.data.datasets = [
        {
          label: 'Temperature (C)',
          tension: .5,
          stepped: true,
          borderWidth: 3,
          radius: 3,
          data: d_sizes,
          backgroundColor: colors.red,
          borderColor: colors.red,
          fill: false
        },
        {
          label: 'Data size (bytes)',
          data: ds_sizes,
          borderDash: [10, 10],
          hoverRadius: 10,
          borderWidth: 1,
          pointStyle: 'dash',
          borderColor: transparentize(colors.black, .9),
          backgroundColor: transparentize(colors.black, .9),
          fill: true,
          tension: 0,
          radius: 0
        }
      ]
      chart.update()
    }

    const refresh = () => {
      fetch('/temp')
      .then(response => response.text())
      .then(data => {
        if (data == lastUpdate) {
          throw Error("noop")
        }
        lastUpdate = data
        return fetch(`/meta?limit=${displayLimit}`)
      })
      .then(response => response.json())
      .then(data => {
        let slice = data.reverse()
        let d_sizes = slice.map(item => item.Data)
        let ds_sizes = slice.map(item => item.DataSize)
        let times = flattenLabels(partitionLabels(slice.map(item => {
          let d = new Date(item.Time * 1000)
          return {
            year: d.getFullYear(),
            month: d.getMonth() + 1,
            day: d.getDate(),
            hour: d.getHours(),
            minute: d.getMinutes(),
          }
        })))

        refreshData(graph, times, d_sizes, ds_sizes)        
      })
      .catch(err => {
        if (err.message != "noop") {
          console.warn(err)
        }
      })
    }

    // Helper functions

    const objectWithoutKey = (object, key) => {
      const {[key]: consume, ...remain} = object
      return remain
    }

    const groupBy = (input, key) => input.reduce((rv, item) => {
      (rv[item[key]] = rv[item[key]] || []).push(objectWithoutKey(item, key))
      return rv
    }, {})

    const flattenLabels = labels => {
      var stack_0 = []
      // YEARS
      Object.keys(labels).forEach(x => {
        // YEARS
        var stack_1 = []
        Object.keys(labels[x]).forEach(y => {
          // MONTHS
          var stack_2 = []
          Object.keys(labels[x][y]).forEach(z => {
            // DAYS
            var stack_3 = []
            Object.keys(labels[x][y][z]).forEach(w => {
              // HOURS
              var stack_4 = []
              var repeat = Object.keys(labels[x][y][z][w]).forEach(m => {
                var test = []
                test.length = labels[x][y][z][w][m].length
                test.fill(w+":"+m)
                stack_4 = stack_4.concat(test)
              })
              stack_3 = stack_3.concat(stack_4)
            })
            stack_3[0] = new Date(x, parseInt(y) - 1, z).toLocaleDateString()+" "+stack_3[0]
            stack_2 = stack_2.concat(stack_3)
          })
          stack_1 = stack_1.concat(stack_2)
        })
        stack_0 = stack_0.concat(stack_1)
      })
      return stack_0
    }

    const partitionLabels = labels => {
      let byYear = groupBy(labels, "year")
      let years = Object.keys(byYear)

      years.forEach(k => {
        let byMonths = groupBy(byYear[k], "month")
        let months = Object.keys(byMonths)

        months.forEach(k => {
          let byDays = groupBy(byMonths[k], "day")
          let days = Object.keys(byDays)

          days.forEach(k => {
            let byHours = groupBy(byDays[k], "hour")
            let hours = Object.keys(byHours)

            hours.forEach(k => {
              let byMinutes = groupBy(byHours[k], "minute")
              byHours[k] = byMinutes
            })

            byDays[k] = byHours
          })

          byMonths[k] = byDays
        })

         byYear[k] = byMonths
      })

      return byYear
    }


    const transparentize = (color, opacity = 0.5) =>
      Color(color).alpha(1 - opacity).rgbString()

    const colors = {
      black: "rgb(10, 10, 10)",
      red: "rgb(255, 99, 132)",
      blue: "rgb(54, 162, 235)"
    }

    // Workflow start
    window.addEventListener('load', () => {
      document.getElementsByTagName("h1")[0].innerHTML = `Temperature of last ${displayLimit} measurements`

      refresh()
      setInterval(refresh, 60*1000)
    }, true)

  </script>
</body>
</html>