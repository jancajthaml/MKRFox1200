<html>
<head>
  <title>Kachnicka</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.4.0/Chart.min.js"></script>
  <style>
    canvas {
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }
    #chart-container {
      height: 70%;
      min-height: 250px;
      max-height: 400px;
      width: 100%
    }
  </style>
</head>
<body>
  <h1>Graph</h1>

  <div id="chart-container" />

  <script>
    // Compile-time constants

    Chart.defaults.global.animation.duration = 0
    const displayLimit = 50

    // Run-time constants

    var lastUpdate = undefined

    const graph = (() => {
      let canvas = document.createElement("canvas")
      document.getElementById("chart-container").appendChild(canvas)

      let ctx = canvas.getContext('2d')
      let chartOptions = {
        type: 'line',
        data: {
          labels: [],
          datasets: []
        },
        options: {
          responsive: true,
          tooltips: {
            mode: 'index',
            intersect: false,
          },
          maintainAspectRatio: false,
          spanGaps: false,
          elements: {
            line: {
              tension: 0.000001
            }
          },
          plugins: {
            filler: {
              propagate: false
            }
          },
          scales: {
            xAxes: [{
              display: true,
              ticks: {
                autoSkip: false
              }
            }],
            yAxes: [{
              display: true,
              beginAtZero: true
            }]
          }
        }
      }
      return new Chart(ctx, chartOptions)
    })()

    // Workflow functions

    const refreshData = (chart, times, d_sizes, ds_sizes) => {
      chart.data.labels = times
      chart.data.datasets = [
      {
        label: 'Data size (bytes)',
        data: ds_sizes,
        borderDash: [5, 5],
        borderColor: transparentize(colors.blue, .5),
        backgroundColor: transparentize(colors.blue, .9),
        fill: true,
        tension: 0,
        radius: 0
      },{
        label: 'Temperature (C)',
        tension: .7,
        data: d_sizes,
        backgroundColor: colors.red,
        borderColor: colors.red,
        fill: false
      }]
      chart.update()
    }

    const refresh = () => {
      fetch('/temp')
      .then(response => response.text())
      .then(data => {
        if (data == lastUpdate) {
          throw Error("noop")
        }
        lastUpdate = data
        return fetch(`/meta?limit=${displayLimit}`)
      })
      .then(response => response.json())
      .then(data => {
        let slice = data.reverse()
        let d_sizes = slice.map(item => item.Data)
        let ds_sizes = slice.map(item => item.DataSize)
        let times = slice.map(item => new Date(item.Time * 1000).toLocaleDateString())
        window.temp = partitionLabels(slice.map(item => {
          let d = new Date(item.Time * 1000)
          return {
            year: d.getFullYear(),
            month: d.getMonth() + 1,
            day: d.getDate(),
            hour: d.getHours(),
            minute: d.getMinutes(),
          }
        }))

        refreshData(graph, times, d_sizes, ds_sizes)        
      })
      .catch(err => {
        if (err.message != "noop") {
          console.warn(err)
        }
      })
    }

    // Helper functions

    const objectWithoutKey = (object, key) => {
      const {[key]: consume, ...remain} = object
      return remain
    }

    const groupBy = (input, key) => input.reduce((rv, item) => {
      (rv[item[key]] = rv[item[key]] || []).push(objectWithoutKey(item, key))
      return rv
    }, {})

    //http://www.chartjs.org/samples/latest/scales/multiline-labels.html
    //labels: [["June","2015"], "July", "August", "September", "October", "November", "December", ["January","2016"],"February", "March", "April", "May"],

    const partitionLabels = labels => {
      let byYear = groupBy(labels, "year")
      let years = Object.keys(byYear)

      years.forEach(k => {
        let byMonths = groupBy(byYear[k], "month")
        let months = Object.keys(byMonths)

        months.forEach(k => {
          let byDays = groupBy(byMonths[k], "day")
          let days = Object.keys(byDays)

          days.forEach(k => {
            let byHours = groupBy(byDays[k], "hour")
            let hours = Object.keys(byHours)

            hours.forEach(k => {
              let byMinutes = groupBy(byHours[k], "minute")
              byHours[k] = byMinutes
            })

            byDays[k] = byHours
          })

          byMonths[k] = byDays
        })

         byYear[k] = byMonths
      })

      return byYear
    }

    const transparentize = (color, opacity = 0.5) =>
      Color(color).alpha(1 - opacity).rgbString()

    const colors = {
      black: "rgb(10, 10, 10)",
      red: "rgb(255, 99, 132)",
      blue: "rgb(54, 162, 235)"
    }

    // Workflow start
    window.addEventListener('load', () => {
      document.getElementsByTagName("h1")[0].innerHTML = `Temperature of last ${displayLimit} measurements`

      refresh()
      setInterval(refresh, 100)
    }, true)

  </script>
</body>
</html>